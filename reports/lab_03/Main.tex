\documentclass[a4paper,12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amssymb,amsfonts,amsmath,mathtext}
\usepackage[unicode]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{{images/}}
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}

\begin{document}

% Титульный лист

\begin{titlepage}
\newpage

\begin{center}

\textit{Министерство науки и высшего образования Российской Федерации \\ 
Федеральное государственное бюджетное образовательное \\
учреждение высшего образования \\
«Московский государственный технический университет \\
имени Н.Э. Баумана (национальный исследовательский университет)» \\
(МГТУ им. Н.Э. Баумана) \\}
\hrulefill
\end{center}

\vspace{2em}

\begin{flushleft}
ФАКУЛЬТЕТ <<Информатика и системы управления>> \\
\vspace{0.5em}
КАФЕДРА <<Программное обеспечение ЭВМ и информационные технологии>>
\end{flushleft}


\vspace{8em}

\begin{center}
\LARGE Лабораторная работа №3 \\
\end{center}

\vspace{1.5em}

\begin{center}
\textsc{Сортировки массивов}
\end{center}

\vspace{6em}

\begin{center}
Головнев Н.В.

\vspace{4em}

ИУ7-54Б
\end{center}

\vspace{\fill}

\begin{center}
Москва 2019
\end{center}

\end{titlepage}

\tableofcontents

% Введение

\newpage
\anonsection{ВВЕДЕНИЕ}
Алгоритмы сортировки - это простые алгоритмы упорядочивания данных, необходимые для удобного просмотра и использования данных.

\newpage
\anonsection{ПОСТАНОВКА ЗАДАЧИ}
Цель задачи: исследовать, оценить и реализовать 3 или более алгоритмов сортировок. Также провести сравнительный анализ этих алгоритмов.\\
Задача: необходимо на выбор реализовать 3 алгоритма сортировки. Выбор средств реализации и требований под программное обеспечение также остается за разработчиком.

\newpage
\section{АНАЛИТИЧЕСКАЯ ЧАСТЬ}
\subsection{Описание алгоритмов}
\subsubsection{Сортировка пузырьком}
Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются $N - 1$ раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде — отсюда и название алгоритма)\cite{Kormen}.

\subsubsection{Шейкерная сортировка}
Шейкер-сортировка является усовершенствованным методом пузырьковой сортировки\cite{Gasfield}. \\
Анализируя метод пузырьковой сортировки, можно отметить два обстоятельства:
\begin{itemize}
\item если при движении по части массива перестановки не происходят, то эта часть массива уже отсортирована и, следовательно, ее можно исключить из рассмотрения;
\item при движении от конца массива к началу минимальный элемент «всплывает» на первую позицию, а максимальный элемент сдвигается только на одну позицию вправо.
\end{itemize}
Эти две идеи приводят к модификациям в методе пузырьковой сортировки:
\begin{itemize}
\item От последней перестановки до конца (начала) массива находятся отсортированные элементы. Учитывая данный факт, просмотр осуществляется не до конца (начала) массива, а до конкретной позиции. Границы сортируемой части массива сдвигаются на 1 позицию на каждой итерации.
\item Массив просматривается поочередно справа налево и слева направо.
\item Просмотр массива осуществляется до тех пор, пока все элементы не встанут в порядке возрастания (убывания).
\item Количество просмотров элементов массива определяется моментом упорядочивания его элементов.
\end{itemize}

\subsubsection{Сортировка поиском минимума и максимума}
В чём идея сортировок выбором?
\begin{enumerate}
\item В неотсортированном подмассиве ищется локальный максимум (минимум).
\item Найденный максимум (минимум) меняется местами с последним (первым) элементом в подмассиве.
\item Если в массиве остались неотсортированные подмассивы — смотри пункт 1.
\end{enumerate}
Похожая идея используется в шейкерной сортировке, которая является вариантом пузырьковой сортировки. Проходя по неотсортированной части массива, мы кроме максимума также попутно находим и минимум. Минимум ставим на первое место, максимум на последнее. Таким образом, неотсортированная часть при каждой итерации уменьшается сразу на два элемента\cite{JonesBarlett}.

\newpage
\subsection{Псевдокоды алгоритмов сортировок}
Псевдокод алгоритма сортировки пузырьком:\\
1 $F \leftarrow 1$ \\
2 while $F = 1$	\\
3 \quad do $F \leftarrow 0$\\
4 \quad\,  for $i \leftarrow 1$ to $n - 1$ \\
5 \quad\,\quad do if $A[i] > A[i + 1]$\\
6 \quad\,\quad\,\quad  then $t \leftarrow A[i]$\\
7 \quad\,\quad\,\quad\, $A[i] \leftarrow A[i + 1]$\\
8 \quad\,\quad\,\quad\, $A[i + 1] \leftarrow t$\\
9 \quad\,\quad\,\quad\, $F \leftarrow 1$ \\
10 end\\

Псевдокод алгоритма шейкерной сортировки:\\
1 $F \leftarrow 1$ \\
2 $k \leftarrow 1$ \\
3 while $F = 1$ and $k < \frac{n}{2}$\\
4 \quad do $F \leftarrow 0$\\
5 \quad\, for $i \leftarrow k$ to $n - k - 1$\\
6 \quad\,\quad do if $A[i] > A[i + 1]$\\
7 \quad\,\quad\,\quad then $t \leftarrow A[i]$\\
8 \quad\,\quad\,\quad\, $A[i] \leftarrow A[i + 1]$\\
9 \quad\,\quad\,\quad\, $A[i + 1] \leftarrow t$\\
10\quad\,\quad\,\quad\, $F \leftarrow 1$\\
11\quad\, for $i \leftarrow n - k - 1$ to $k$\\
12\quad\,\quad do if $A[i] > A[i + 1]$\\
13\quad\,\quad\,\quad then $t \leftarrow A[i]$\\
14\quad\,\quad\,\quad\, $A[i] \leftarrow A[i + 1]$\\
15\quad\,\quad\,\quad\, $A[i + 1] \leftarrow t$\\
16\quad\,\quad\,\quad\, $F \leftarrow 1$\\
17 end\\

Псевдокод алгоритма сортировки двустороннего выбора (минимум/максимум):\\
1 for $k \leftarrow 1$ to $\frac{n}{2}$\\
2 \quad do $mini \leftarrow k$\\
3 \quad\, $maxi \leftarrow n - k$\\
4 \quad\, $min \leftarrow A[mini]$\\
5 \quad\, $max \leftarrow A[maxi]$\\
6 \quad\, for $i \leftarrow k$ to $n - k$\\
7 \quad\,\quad do if $A[i] > max$\\
8 \quad\,\quad\,\quad then $maxi \leftarrow i$\\
9 \quad\,\quad\,\quad\, $max \leftarrow A[i]$\\
10\quad\,\quad\, if $A[i] < min$\\
11\quad\,\quad\,\quad then $mini \leftarrow i$\\
12\quad\,\quad\,\quad\, $min \leftarrow A[i]$\\
13\quad\, if $maxi = k$\\
14\quad\,\quad then $t \leftarrow A[k]$\\
15\quad\,\quad\, $A[k] \leftarrow A[mini]$\\
16\quad\,\quad\, $A[mini] \leftarrow a[n - k]$\\
17\quad\,\quad\, $A[n - k] \leftarrow t$\\
18\quad\, else if $mini = n - k$\\
19\quad\,\quad then $t \leftarrow A[n - k]$\\
20\quad\,\quad\, $A[n - k] \leftarrow A[maxi]$\\
21\quad\,\quad\, $A[maxi] \leftarrow a[k]$\\
22\quad\,\quad\, $A[k] \leftarrow t$\\
23\quad\, else\\
24\quad\,\quad then $t \leftarrow A[mini]$\\
25\quad\,\quad\, $A[mini] \leftarrow A[k]$\\
26\quad\,\quad\, $A[k] \leftarrow t$\\
27\quad\,\quad then $t \leftarrow A[maxi]$\\
28\quad\,\quad\, $A[maxi] \leftarrow A[n - k]$\\
29\quad\,\quad\, $A[n - k] \leftarrow t$\\
30 end\\

\newpage
\subsection{Оценка трудоемкости алгоритмов}
\begin{center}
\textbf{Модель вычислений}
\end{center}
\begin{enumerate}
\item Объявление переменной/массива/структуры имеет трудоемкость 0;
\item Арифметические и логические операции имеют трудоемкость 1;
\item Операции разыменовании и индексации имеют трудоемкость 1;
\item Условный оператор (без условий внутри) имеет трудоемкость 0;
\item Оператор цикла for имеет трудоемкость $1 + n * (3 + T)$, где n - это число повторений цикла, T - трудоемкость тела цикла;
\item Оператор цикла while имеет трудоемкость $1 + n * (1 + T)$;
\end{enumerate}
\begin{center}
\textbf{Функции трудоемкости}
\end{center}
1)Сортировка пузырьком:\\
Лучший случай (массив отсортирован):\\
\begin{equation}
F(n) = 5 + 7(n - 1) \sim \Theta(n)
\end{equation}
Худший случай (массив отсортирован по убыванию):\\
\begin{equation}
F(n) = 12n^2 - 16n + 6 \sim \Theta(n^2)
\end{equation}
2)Шейкерная сортировка:\\
Лучший случай (массив отсортирован):\\
\begin{equation}
F(n) = 14n + 8 \sim \Theta(n)
\end{equation}
Худший случай (массив отсортирован по убыванию):$\sim \Theta(n^2)$\\
3)Сортировка двустороннего выбора (сортировка минимум/максимум):\\
Работа данного алгоритма почти не зависит от значений массива (зависит только кол-во операций внутри каждого подцикла, но кол-во циклов от этого не меняется). Кол-во операций:\\
\begin{equation}
F(n) = an^2 + bn + c \sim \Theta(n^2)
\end{equation}

\newpage
\subsection{Вывод}
Аналитически были описаны принципы работы 3-х алгоритмов сортировки:
\begin{itemize}
\item Сортировка пузырьком;
\item Шейкерная сортировка;
\item Сортировка двусторонним выбором; 
\end{itemize}
Для лучшего случая самым быстрым алгоритмом является алгоритм сортировки пузырьком. В лучшем случае у сортировки пузырьком и шейкерной сортировки оценки трудоемкости составляют $\Theta(n)$. В худшем случае оценка трудоемкости для всех 3-x алгоритмов сортировок составляет $\Theta(n^2)$. Оценка трудоемкости алгоритма сортировки двусторонним выбором не зависит от значений массива (зависит кол-во операций).

% Конструкторская часть

\newpage
\section{КОНСТРУКТОРСКАЯ ЧАСТЬ}

\subsection{Разработка алгоритмов}
На вход у всех алгоритмов передаются в качестве параметров:
\begin{enumerate}
\item Массив;
\item Размер массива;
\end{enumerate}
Возвращаемое значение: код ошибки (0 в случае успеха, иначе отрицательное значение). \\
Побочные эффекты: массив сортируется.

\newpage
\subsection{Схемы алгоритмов}
Ниже представлены схемы алгоритмов сортировок (сортировка пузырьком, сортировка минимум/максимум, шейкерная сортировка).
\begin{figure}[H]
\center{\includegraphics[scale=0.25]{sort_bubble.png}}
\caption{Схема алгоритма сортировки пузырьком}
\label{images:scheme1}
\end{figure}
\begin{figure}[p]
\center{\includegraphics[scale=0.2]{sort_min_max.png}}
\caption{Схема алгоритма сортировки минимум/максимум}
\label{images:scheme2}
\end{figure}
\begin{figure}[p]
\center{\includegraphics[scale=0.2]{sort_shaker.png}}
\caption{Схема алгоритма шейкерной сортировки}
\label{images:scheme3}
\end{figure}

\newpage
\subsection{Вывод}
На основе аналитических данных были разработаны требования к разрабатываемым лагоритм, а также приблизительные схемы работы алгоритмов.


\newpage
\section{ТЕХНОЛОГИЧЕСКАЯ ЧАСТЬ}
\subsection{Требования к программному обеспечению}

Программа должна работать на операционной системе Arch Linux. Программа должна содержать 2 режима:
\begin{itemize}
\item Пользовательский
\item Экспериментальный
\end{itemize}
В пользовательском режиме пользователь должен иметь возможность вводить строки и получать результат работы 3-х алгоритмов. В экспериментальном режиме засекается процессорное время работы каждого алгоритма, результаты записываются в отдельные файлы. Впоследствии данные из этих файлов можно вывести в виде графика.

\newpage
\subsection{Средства реализации}
Для реализации данных алгоритмов был выбран язык программирования С, компилятор gcc и некоторые функции из библиотеки glibc (memcpy, malloc и тд...). \\
Основные особенности Си:
\begin{itemize}
\item простая языковая база, из которой в стандартную библиотеку вынесены многие существенные возможности, вроде математических функций или функций работы с файлами;
\item ориентация на процедурное программирование;
\item система типов, предохраняющая от бессмысленных операций;
\item использование препроцессора для абстрагирования однотипных операций;
\item доступ к памяти через использование указателей;
\item небольшое число ключевых слов;
\item передача параметров в функцию по значению, а не по ссылке (передача по ссылке эмулируется с помощью указателей);
\item наличие указателей на функции и статических переменных;
\item области видимости имён;
\item структуры и объединения — определяемые пользователем собирательные типы данных, которыми можно манипулировать как одним целым.
\end{itemize}
Для вывода графиков использовался Python3 версии 3.7. В качестве библиотеки для отрисовки графиков была выбрана Matplotlib.

\newpage
\subsection{Листинг кода}
Ниже приведены реализации алгоритмов на С.\\
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily
}

\lstinputlisting[captionpos=b, caption=\label{listings:listing2}Сортировка пузырьком(\ref{images:scheme1}), style=customc]{listing2.c}
\newpage
\lstinputlisting[captionpos=b, caption=\label{listings:listing1}Сортировка минимум/максимум (двусторонняя сортировка выбором)(\ref{images:scheme2}), style=customc]{listing1.c}
\newpage
\lstinputlisting[captionpos=b, caption=\label{listings:listing3}Шейкерная сортировка(\ref{images:scheme3}), style=customc]{listing3.c}

\newpage
\subsection{Вывод}
Используя язык программирования C, в ходе практической работы были спроектированы и написаны реализации алгоритмов сортировки. Используя эти реализации были написаны 2 приложения: пользовательское приложение и приложение для подсчета времени выполнения этих алгоритмов.

\newpage
\section{ЭКСПЕРИМЕНТАЛЬНАЯ ЧАСТЬ}
\subsection{Характеристики аппаратного и программного обеспечения}
% Часть которую никогда нельзя менять
Тестирование приложения проводилось на машине со следующими характеристиками:\\
\begin{itemize}
\item Процессор Intel® Core™ i7-7700HQ;
\item Оперативная память 16 ГБ;
\item Операционная система - Arch Linux с рабочим окружением Cinnamon.
\end{itemize}

\newpage
\subsection{Примеры работы}
На Рис. \ref{images:example}, предсавленном ниже, демонстрируется работа приложения. Запуск приложения осуществляется из эмулятора терминала в Arch Linux. Во время работы приложение запрашивает у пользователя параметры массива и выводит результаты сортировки на экран.
\begin{figure}[h]
\center{\includegraphics[scale=0.5]{example.png}}
\caption{Пример работы приложения}
\label{images:example}
\end{figure}

\newpage
\subsection{Результаты тестирования}
Ниже в таблице предоставлены результаты тестирования приложения.
Все результаты корректны и ссответствуют теоретическим результатам.
\begin{table}[h]
\caption{\label{tablice:tests}Результаты тестирования приложения}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Массив & Реультат 1 & Результат 2 & Результат 3 \\
\hline
1 & 1 & 1 & 1 \\
\hline
1 2 3 & 1 2 3 & 1 2 3 & 1 2 3 \\
\hline
2 1 & 1 2 & 1 2 & 1 2 \\
\hline
2 1 3 & 1 2 3 & 1 2 3 & 1 2 3 \\
\hline
3 2 1 & 1 2 3 & 1 2 3 & 1 2 3 \\
\hline
4 3 2 1 & 1 2 3 4 & 1 2 3 4 & 1 2 3 4 \\
\hline
\end{tabular}
\end{center}
\end{table}

\newpage
\subsection{Постановка эксперимента по замеру времени}
Для вычисления процессорного времени работы алгоритмов использовалась функция clock(), объявленная в заголовочном файле time.h из библиотеки glibc. \\
Требования к программе, считающей время выполнения алгоритмов:
\begin{itemize}
\item Ввод пользователем таких параметров, как:
\begin{itemize}
\item Максимальный размер массива;
\item Кол-во итераций на каждый рассматриваемый случай (для высчитывания среднего значения времени);
\end{itemize}
\item Массивы генерируются со случайными числами;
\item Результаты вычислений должны сохранятся в текстовых файлах.
\end{itemize}

\newpage
\subsection{Сравнительный анализ на материале экспериментальных данных}
На Рис. \ref{images:graphics1},\ref{images:graphics2},\ref{images:graphics3} приведены графики зависимостей времени выполнения сортировок от размера массива. Единица измерения времени – временный такт процессора. \\

\begin{figure}[h]
\center{\includegraphics[scale=1]{graphics_sorted.png}}
\caption{График зависимости времени выполнения сортировок от размера массива}
\label{images:graphics1}
\end{figure}
\begin{figure}[H]
\center{\includegraphics[scale=1]{graphics_random.png}}
\caption{График зависимости времени выполнения сортировок от размера массива}
\label{images:graphics2}
\end{figure}
\begin{figure}[H]
\center{\includegraphics[scale=1]{graphics_unsorted.png}}
\caption{График зависимости времени выполнения сортировок от размера массива}
\label{images:graphics3}
\end{figure}

\newpage
\subsection{Оценка затрачиваемой памяти}
Размер памяти (в байтах) $M$, используемый во всех предоставленных алгоритмов сортировки можно вычислить по формуле:\\
\begin{equation}
M = N * t + S
\end{equation}
где:\\
$N$ - Кол-во элементов,\\
$t$ - размер типа данных в байтах(например, для integer - 4 байт, для double 8 байт),\\
$S$ - Память, выделяемая под вспомогательные элементы.\\

\newpage
\subsection{Вывод}
В результате исследования оценки времени выполнения можно сделать вывод, что сортировка пузырьком имеет самые худшие временные показатели. Сортировка методом поиска минимума и максимума самая быстрая и не зависит от расположения элементов. Для того, чтобы не наблюдалось случая, как представлено на графике[\ref{images:graphics1}], достаточно сделать вначале проверку на сортированость.

\newpage
\anonsection{ЗАКЛЮЧЕНИЕ}
Основное и единственное предназначение алгоритмов сортировок - упорядочивать данные. Везде где есть базы данных нужно так или иначе сортировать списки данных как для удобства пользователя, так и для индексации таблиц что бы быстро работал поиск. В библиотеке данные о книгах могут быть отсортированы по названию, по автору, по жанрам, по году издания. Тогда намного легче по картотеке или электронной базе найти интересующий экземпляр.


\newpage
\anonsection{СПИСОК ИСТОЧНИКОВ}
\begingroup
\renewcommand{\section}[2]{}
\begin{thebibliography}{3}
\bibitem{JonesBarlett} Jones Barlett, Analysis of Algorithms: An Active Learning Approach.
\bibitem{Gasfield} Гасфилд. Строки, деревья и последовательности в алгоритмах. Информатика и вычислительная биология. Невский Диалект БВХ-Петербург, 2003.
\bibitem{Kormen} Кормен, Томас Х., Лейзерсон, Чарльз И., Ривест, Рональд Л., Штайн, Клифорд. Глава 28. Работа с матрицами // Алгоритмы: построение и анализ = Introduction to Algorithms. — 2-e издание. — М.: «Вильямс», 2005. — С. 833 - 839. — ISBN 5-8459-0857-4.
\end{thebibliography}
\endgroup

\end{document}
